From 77f24a2e6276d06d1da1f6d9223b5b15e6ab04ac Mon Sep 17 00:00:00 2001
Message-Id: <77f24a2e6276d06d1da1f6d9223b5b15e6ab04ac@dist-git>
From: Andrea Bolognani <abologna@redhat.com>
Date: Wed, 5 Aug 2015 18:18:25 +0200
Subject: [PATCH] nodeinfo: Add old kernel compatibility to
 nodeGetPresentCPUBitmap()

If the cpu/present file is not available, we assume that the kernel
is too old to support non-consecutive CPU ids and return a bitmap
with all the bits set to represent this fact. This assumption is
already exploited in nodeGetCPUCount().

This means users of this API can expect the information to always
be available unless an error has occurred, and no longer need to
treat the NULL return value as a special case.

The error message has been updated as well.

(cherry picked from commit 37f73e4ad5b049edbd92951330db2c071ca93b87)

Bug: https://bugzilla.redhat.com/show_bug.cgi?id=1213713

Signed-off-by: Andrea Bolognani <abologna@redhat.com>
Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 src/nodeinfo.c | 43 +++++++++++++++++++++++++++++--------------
 1 file changed, 29 insertions(+), 14 deletions(-)

diff --git a/src/nodeinfo.c b/src/nodeinfo.c
index a7a5d98..ceb517a 100644
--- a/src/nodeinfo.c
+++ b/src/nodeinfo.c
@@ -441,6 +441,8 @@ virNodeParseNode(const char *sysfs_prefix,
     }
 
     present_cpumap = nodeGetPresentCPUBitmap(sysfs_prefix);
+    if (!present_cpumap)
+        goto cleanup;
 
     /* enumerate sockets in the node */
     CPU_ZERO(&sock_map);
@@ -448,7 +450,7 @@ virNodeParseNode(const char *sysfs_prefix,
         if (sscanf(cpudirent->d_name, "cpu%u", &cpu) != 1)
             continue;
 
-        if (present_cpumap && !(virBitmapIsBitSet(present_cpumap, cpu)))
+        if (!virBitmapIsBitSet(present_cpumap, cpu))
             continue;
 
         if ((online = virNodeGetCpuValue(node, cpu, "online", 1)) < 0)
@@ -484,7 +486,7 @@ virNodeParseNode(const char *sysfs_prefix,
         if (sscanf(cpudirent->d_name, "cpu%u", &cpu) != 1)
             continue;
 
-        if (present_cpumap && !(virBitmapIsBitSet(present_cpumap, cpu)))
+        if (!virBitmapIsBitSet(present_cpumap, cpu))
             continue;
 
         if ((online = virNodeGetCpuValue(node, cpu, "online", 1)) < 0)
@@ -1284,27 +1286,40 @@ nodeGetCPUCount(const char *sysfs_prefix ATTRIBUTE_UNUSED)
 }
 
 virBitmapPtr
-nodeGetPresentCPUBitmap(const char *sysfs_prefix)
+nodeGetPresentCPUBitmap(const char *sysfs_prefix ATTRIBUTE_UNUSED)
 {
-    int max_present;
 #ifdef __linux__
+    virBitmapPtr present_cpus = NULL;
     char *present_path = NULL;
-    virBitmapPtr bitmap = NULL;
-#endif
+    int npresent_cpus;
 
-    if ((max_present = nodeGetCPUCount(sysfs_prefix)) < 0)
-        return NULL;
+    if ((npresent_cpus = nodeGetCPUCount(sysfs_prefix)) < 0)
+        goto cleanup;
 
-#ifdef __linux__
     if (!(present_path = linuxGetCPUPresentPath(sysfs_prefix)))
-        return NULL;
-    if (virFileExists(present_path))
-        bitmap = linuxParseCPUmap(max_present, present_path);
+        goto cleanup;
+
+    /* If the cpu/present file is available, parse it and exit */
+    if (virFileExists(present_path)) {
+        present_cpus = linuxParseCPUmap(npresent_cpus, present_path);
+        goto cleanup;
+    }
+
+    /* If the file is not available, we can assume that the kernel is
+     * too old to support non-consecutive CPU ids and just mark all
+     * possible CPUs as present */
+    if (!(present_cpus = virBitmapNew(npresent_cpus)))
+        goto cleanup;
+
+    virBitmapSetAll(present_cpus);
+
+ cleanup:
     VIR_FREE(present_path);
-    return bitmap;
+
+    return present_cpus;
 #endif
     virReportError(VIR_ERR_NO_SUPPORT, "%s",
-                   _("non-continuous host cpu numbers not implemented on this platform"));
+                   _("node present CPU map not implemented on this platform"));
     return NULL;
 }
 
-- 
2.5.0

