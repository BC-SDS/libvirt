From 66f6a0bad6db35e654b0625d5a3fac939899c997 Mon Sep 17 00:00:00 2001
Message-Id: <66f6a0bad6db35e654b0625d5a3fac939899c997@dist-git>
From: Andrea Bolognani <abologna@redhat.com>
Date: Fri, 20 Nov 2015 13:29:12 +0100
Subject: [PATCH] qemu: Use qemuDomainRequiresMlock() in qemuBuildCommandLine()

This removes a duplication of the logic used to decide whether
the memory locking limit should be set.

(cherry picked from commit cf9bd256556cfa1343e4438e4807625c9e1af921)

Bug: https://bugzilla.redhat.com/show_bug.cgi?id=1283924

Signed-off-by: Andrea Bolognani <abologna@redhat.com>
Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 src/qemu/qemu_command.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/src/qemu/qemu_command.c b/src/qemu/qemu_command.c
index 7f8a31b..ece6081 100644
--- a/src/qemu/qemu_command.c
+++ b/src/qemu/qemu_command.c
@@ -8974,7 +8974,6 @@ qemuBuildCommandLine(virConnectPtr conn,
     int usbcontroller = 0;
     int actualSerials = 0;
     bool usblegacy = false;
-    bool mlock = false;
     int contOrder[] = {
         /*
          * List of controller types that we add commandline args for,
@@ -9158,7 +9157,6 @@ qemuBuildCommandLine(virConnectPtr conn,
         virCommandAddArgFormat(cmd, "mlock=%s",
                                def->mem.locked ? "on" : "off");
     }
-    mlock = def->mem.locked;
 
     virCommandAddArg(cmd, "-smp");
     if (!(smp = qemuBuildSmpArgStr(def, qemuCaps)))
@@ -10850,9 +10848,6 @@ qemuBuildCommandLine(virConnectPtr conn,
                                      "supported by this version of qemu"));
                     goto error;
                 }
-                /* VFIO requires all of the guest's memory to be locked
-                 * resident */
-                mlock = true;
             }
 
             if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE)) {
@@ -11146,7 +11141,9 @@ qemuBuildCommandLine(virConnectPtr conn,
             goto error;
     }
 
-    if (mlock)
+    /* In some situations, eg. VFIO passthrough, QEMU might need to lock a
+     * significant amount of memory, so we need to set the limit accordingly */
+    if (qemuDomainRequiresMlock(def))
         virCommandSetMaxMemLock(cmd, qemuDomainGetMlockLimitBytes(def));
 
     if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_MSG_TIMESTAMP) &&
-- 
2.6.3

